\newsavebox\funlmactxframe

\lstset{
	basicstyle=\ttfamily,
	columns=fullflexible,
	%frame=single,
	breaklines=true,
	postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

\begin{lrbox}{\funlmactxframe}
\begin{lstlisting}
void lmacTxFrame(int param_1,int param_2)
{
    /*Decompiled code from the original libraries*/
    4000a06a 93 97 49 03 li     a5,0x34
    4000a06e b3 87 f5 02 mul    a5,a1,a5
    4000a072 01 11       c.addi sp,-0x20
    4000a074 22 cc       c.swsp s0,0x18(sp)
    4000a076 37 04 88 40 lui    s0,0x40880
    4000a07a 52 c4       c.swsp s4,0x8(sp)
    ...
    (&DAT_600a4d6c)[uVar8 * -4] = (&DAT_600a4d6c)[uVar8 * -4] | 0xc0000000;
    /*In assembly:*/
    4000a208 98 43       c.lw   a4,0x0(a5)
    4000a20a b7 06 00 c0 lui    a3,0xc0000
    4000a20e 55 8f       c.or   a4,a3
    4000a210 98 c3       c.sw   a4,0x0(a5)
    ...
}
\end{lstlisting}
\end{lrbox}

\newsavebox\funpatchlmactxframe
\begin{lrbox}{\funpatchlmactxframe}
\begin{lstlisting}
void patched_lmacTxFrame(int param_1,int param_2)
{
    /*Our patched version of lmacTxFrame*/
}
\end{lstlisting}
\end{lrbox}

\newsavebox\funactivation
\begin{lrbox}{\funactivation}
\begin{lstlisting}
void activation()
{
    /*Our activation function*/
    // lui+jalr to call_lmacTxFrame
    uint32_t lui_instr  = 0x4200c0b7;   // LUI instruction
    uint32_t jalr_instr = 0x1b4080e7;  // JALR instruction

    uint32_t *base_ppProcessTxQ = (uint32_t *) 0x4080e3fc;
    uint32_t offset_ppProcessTxQ = 0x70; // 0x4080e46c - 0x4080e3fc

    // ppProcessTxQ
    uint32_t *ppProcessTxQ_lui = \
        (uint32_t *)((char *)base_ppProcessTxQ +\
                     offset_ppProcessTxQ);
    uint32_t *ppProcessTxQ_jalr = \
        (uint32_t *)((char *)base_ppProcessTxQ +\
                     offset_ppProcessTxQ + 0x4);
    *ppProcessTxQ_lui = lui_instr;
    *ppProcessTxQ_jalr = jalr_instr;    
}
\end{lstlisting}
\end{lrbox}

\newsavebox\funcalllmactxframe
\begin{lrbox}{\funcalllmactxframe}
\begin{lstlisting}
/*Suppose the compiled code starts at 
  0x4200c1b4*/
void call_lmacTxFrame(int param_1,int param_2)
{
    /*Our function to call lmacTxFrame*/
    counter++; // A global counter of how 
               // many times lmacTxFrame is called
    /*Do some processing such as changing the
      channel before calling lmacTxFrame*/
    return lmacTxFrame(param_1,param_2);
    /* Or return patched_lmacTxFrame(param_1,param_2)
       in case we want to patch the original function*/
}
\end{lstlisting}
\end{lrbox}

\newsavebox\funprocesstxq
\begin{lrbox}{\funprocesstxq}
\begin{lstlisting}
void processTxQ()
{
    /*One among different functions from the 
      original library that call lmacTxFrame*/
    4080e3fc 41 11       c.addi  sp,-0x10
    4080e3fe 26 c2       c.swsp  s1,0x4(sp)
    4080e400 06 c6       c.swsp  ra,0xc(sp)
    4080e402 22 c4       c.swsp  s0,0x8(sp)
    4080e404 aa 84       c.mv    s1,a0
    ... 
    4080e46c b7 a0 00 40 lui     ra,0x4000a
    4080e470 e7 80 a0 06 jalr    ra,ra,offset=0x06a lmacTxFrame 
    ...
}
\end{lstlisting}
\end{lrbox}


\newsavebox\funprocesstxqaft
\begin{lrbox}{\funprocesstxqaft}
\begin{lstlisting}
void processTxQ()
{
    /*One among different functions from the 
      original library that calls lmacTxFrame*/
    4080e3fc 41 11       c.addi  sp,-0x10
    4080e3fe 26 c2       c.swsp  s1,0x4(sp)
    4080e400 06 c6       c.swsp  ra,0xc(sp)
    4080e402 22 c4       c.swsp  s0,0x8(sp)
    4080e404 aa 84       c.mv    s1,a0
    ... 
    4080e46c b7 c0 00 42 lui     ra,0x4200c
    4080e470 e7 80 40 1b jalr    ra,ra,offset=0x1b4 call_lmacTxFrame 
    ...
}
\end{lstlisting}
\end{lrbox}

\newsavebox\funpropcode
\begin{lrbox}{\funpropcode}
\begin{lstlisting}
{
/* Proprietary code that calls 
   different functions among which
   those that call lmacTxFrame,
   such as ppProcessTxQ */
     ...
     ppProcessTxQ();
     ...
}
\end{lstlisting}
\end{lrbox}


\newsavebox\funmain
\begin{lrbox}{\funmain}
\begin{lstlisting}
void main()
{
    ...
    /* Before activation, the call flow
       is ppProcessTxQ -> lmacTxFrame */
    activation();
    /* After activation, the call flow
       is ppProcessTxQ -> call_lmacTxFrame
          -> lmacTxFrame (or patched_lmacTxFrame) */
    ...
}
\end{lstlisting}
\end{lrbox}

% TEXT HERE
% TEXT HERE
% TEXT HERE
% TEXT HERE

During activiies of reverse engineering there is often the need to analyze a specific function
in a specific context, e.g. calling that function directly without going through the whole
workflow would be pointless; in other occasions it is necessary to know how and when said target
function is called. Tools such as GDB allow to set breakpoints and analyze the call stack,
but not always the result is satisfactory.

In our specific case, after repeated attempts with GDB (and many \texttt{step over} and \texttt{step into} commands)
we managed to understand the lowest level function and the lowest level instruction that sends a frame to the radio,
that is, the function \texttt{void lmacTxFrame(int param\_1,int param\_2)} and the instruction \texttt{c.sw a4,0x0(a5)}
at address \texttt{0x4000a210}.
The inconvenience during our analysis was that breakpoints were not correctly set to the function \texttt{lmacTxFrame},so we relied on a technique that we call \textit{hooking}: we found with Ghidra the functions that call
\texttt{lmacTxFrame} (among which the most important one is \texttt{ppProcessTxQ}, then we created our own wrapper function that we called \texttt{call\_lmacTxFrame} and we 
modified \texttt{ppProcessTxQ} and all the functions that would normally call \texttt{lmacTxFrame}
so that they would call \texttt{call\_lmacTxFrame} instead. 
The way we chose to modify \texttt{ppProcessTxQ} (and the other functions, but from now we will refer only to
\texttt{ppProcessTxQ}) was to inject assembly code that would mimic the call to \texttt{lmacTxFrame},
by replacing the known address of our \texttt{call\_lmacTxFrame} function we forced the call to our function.

This is the look of the original function \texttt{lmacTxFrame}:

\usebox\funlmactxframe

This is the look of the function \texttt{ppProcessTxQ} that calls \texttt{lmacTxFrame}:

\usebox\funprocesstxq

This is the look of the wrapper function \texttt{call\_lmacTxFrame} that we wrote in order
to hook the call to \texttt{lmacTxFrame}:

\usebox\funcalllmactxframe

And this is the \textit{activation} function that we wrote to inject assembly code in \texttt{ppProcessTxQ}:

\usebox\funactivation


Notice that here we are injecting custom assembly code at a chosen address in the binary,
before this step we also injected custom assembly code but without chosing the specific address,
the intention was simply to test the assembly code that we wanted to inject to check whether it would
actually jump to a specific address, we adopted a method similar to what is called \textit{shellcode injection}.
\newsavebox\shellcode
\begin{lrbox}{\shellcode}
\begin{lstlisting}
    // Shellcode to jump to a specific address
    unsigned char shellcode[] = { 
        0x40, 0x00, 0xa0, 0xb7, // lui ra,0x4000a
	0x06, 0xa0, 0x80, 0xe7  // jalr ra,ra,offset=0x06a
    };

    // Execution of the shellcode
    void (*execute_shellcode)(void) = (void (*)(void))shellcode;
    execute_shellcode();

    edit_return_to_call_patched_lmacTxFrame();
\end{lstlisting}
\end{lrbox}

\usebox\shellcode

The assembly code is saved in the variable \texttt{shellcode}, then the area of memory where the
shellcode is stored is interpreted as code thanks to the cast to a pointer to a function that
takes \texttt{void} and returns \texttt{void}. Notice that if the function at 
\texttt{0x4000a06a} takes arguments, this shellcode will not pass said parameters correctly,
in order to pass parameters correctly we would need to load the values in the appropriate registers,
in RISC-V the first 8 arguments are passed in the registers \texttt{a0} to \texttt{a7} and 
the return value is passed in \texttt{a0}, further arguments are passed on the stack.

\begin{figure*}[ht]
\begin{tikzpicture}[scale=0.5, 
		    every node/.append style={transform shape}]
	\node[draw] (nfunmain) {\usebox\funmain};
	\node[draw, below=5cm of nfunmain] (nfunactivation) {\usebox\funactivation};
	\node[draw, right=6cm of nfunmain] (nfunprocesstxq) {\usebox\funprocesstxq};
	\node[draw, above=of nfunprocesstxq] (nfunpropcode) {\usebox\funpropcode};
	\node[draw, below=of nfunprocesstxq] (nfunlmactxframe) {\usebox\funlmactxframe};
	\node[draw, below=of nfunlmactxframe] (nfunprocesstxqaft) {\usebox\funprocesstxqaft};
	\node[draw, below=of nfunprocesstxqaft] (nfuncalllmactxframe) {\usebox\funcalllmactxframe};
	%\node[draw, below left=of nfuncalllmactxframe] (nfunlmactxframe) {\usebox\funlmactxframe};
	\node[draw, below=of nfuncalllmactxframe] (nfunpatchlmactxframe) {\usebox\funpatchlmactxframe};

	% using to for the edge between the nodes with in and out angles and text auto sloped
	\draw[->] (nfunmain) to[out=-100,in=100] node[auto,sloped] {} (nfunactivation);
	\draw[->, color=red] (nfunactivation) to[out=90,in=200] node[auto,sloped] {Injecting assembly} (nfunprocesstxq);
	\draw[->, color=red] (nfunprocesstxq) to[out=20, in=20, looseness=0.8] node[auto,sloped] {} (nfunprocesstxqaft);

	% Before activation
	\draw[->] (nfunpropcode) to[out=0, in=10] node[auto,sloped] {before \texttt{activation()}} (nfunprocesstxq);
	\draw[->] (nfunprocesstxq) to[out=0, in=10] node[auto,sloped] {} (nfunlmactxframe);
	\draw[->, color=blue] (nfunpropcode) to[out=10, in=10,looseness=0.8] node[auto,sloped,pos=0.2] {after \texttt{activation()}} (nfunprocesstxqaft);
	\draw[->, color=blue] (nfunprocesstxqaft) to[out=0, in=10] node[auto,sloped,] {} (nfuncalllmactxframe);
	\draw[->, color=blue] (nfuncalllmactxframe) to[out=170, in=180,looseness=0.5] node[auto,sloped] {} (nfunlmactxframe);
	\draw[->, color=green,] (nfuncalllmactxframe) to[out=190, in=180, looseness=0.8] node[auto,sloped] {} (nfunpatchlmactxframe);
	

\end{tikzpicture}

\caption{Original function processTxQ and the function after activation}
\label{fig:workflowchange}

\end{figure*}

